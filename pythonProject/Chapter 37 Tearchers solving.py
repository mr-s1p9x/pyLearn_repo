### Задача 1 ###
# 1. Создайте функцию dict_to_list, которая будет конвертировать 
# словарь в список кортежей

# 2. Функция должна принимать словарь, а возвращать список кортежей, в каждом кортеже
# должны быть пары (key, value) из словаря

# 3. Если значение ключа - целое 

# Функция, которая преобразует словарь в список кортежей
def dict_to_list(dict_to_convert):
    # Создаём пустой список, куда будем добавлять кортежи (ключ, значение)
    list_for_convertion = []

    # Перебираем все пары ключ-значение в словаре
    for k, v in dict_to_convert.items():
        # Если значение — целое число (type строго int, исключая bool)
        if type(v) == int:
            # Умножаем это значение на 2
            v *= 2

        # Добавляем кортеж (ключ, значение) в список
        list_for_convertion.append((k, v))
    
    # Возвращаем финальный список кортежей
    return list_for_convertion

# Вызываем функцию с примерным словарём
# 'a': True → не сработает, потому что type(True) == bool, а не int
# 'b': []   → список, игнорируется
# 'c': 200 → целое число, будет умножено на 2
print(dict_to_list({'a': True, 'b': [], 'c': 200}))


##########################################################################


### Задача 2 ###
# 1. Создайте функцию filter_list, которая будет фильтровать список

# 2. У функции должно быть два параметра - список и тип значения

# 3. Функция должна вернуть новый список, в котором останутся только значения
# того типа, который был передан в вызове функции вторым аргументом

#[функция должна принимать список из разных типов, и вернуть результирующий список из 1 типов]
# 4. К примеру, мы вызываем функцию так:
# filter_list([35, True, 'abc', 10]) int) и получаем [35, 10]
# использовать нужно for in внутри функции

# Первая версия фильтрации без filter(), вручную через цикл
def filter_list(list_to_filter, data_type):
    # Создаём пустой список, куда будем добавлять отфильтрованные значения
    filtered_list = []

    # Перебираем все элементы в списке
    for el in list_to_filter:
        # Проверяем, является ли элемент строго нужным типом (без bool)
         # Например, type(True) == bool → не добавится, даже если data_type == int
        if type(el) == data_type:
            filtered_list.append(el)
    
    # Возвращаем отфильтрованный список
    return filtered_list

# Пример: фильтруем только целые числа (исключая True/False)
print(filter_list([10, True, 'hello', 35, False], int))

# Пример: фильтруем только строки
print(filter_list([10, True, 'hello', 35, 'ziabls', False], str))

# Пример: фильтруем только значения типа float
print(filter_list([10, True, 'hello', 35, 23.3, False, 2231.34], float))

print("#################")

##########################################################################
# Вторая версия — через встроенную функцию filter (с функцией внутри)
def filter_list(list_to_filter, value_type):
     # Вложенная функция-проверка типа элемента
    def check_element_type(elem):
        return isinstance(elem, value_type) # Возвращает True, если элемент указанного типа

    # Функция filter возвращает генератор, преобразуем его в список
    return list(filter(check_element_type, list_to_filter))

# Альтернативно можно использовать lambda-функцию:
# return list(filter(lambda elem: type(elem) is value_type, list_to_filter))

# Пример: фильтруем только целые числа
res = filter_list([1, 10, 'abc', 5.5, 'hello'], int)
print(res) # → [1, 10]

print()

# Проверка, как Python воспринимает True
print(isinstance(True, bool))     # → True (это логический тип)
print(isinstance(True, int))      # → True (потому что bool — это подкласс int)
print(isinstance(True, object))   # → True (всё в Python — объект)

# Выводим все подклассы типа int
# Покажет, что bool — один из них
print(int.__subclasses__())  # → [<class 'bool'>]